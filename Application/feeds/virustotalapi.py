
import requests
import os


from Feeds.feeder import Feeder
import Feeds.constants as C

description="VirusTotal's Public ApÄ± implemantation"

class PublicApi(Feeder):
    """ VirusTotal's Public API lets you upload and scan files, submit and scan URLs, access finished scan reports
    and make automatic comments on URLs and samples without the need of using the HTML website interface. In other
    words, it allows you to build simple scripts to access the information generated by VirusTotal.
    The chosen format for the API is HTTP POST requests with JSON object responses and it is limited to at most 4
    requests of any nature in any given 1 minute time frame. If you run a honeyclient, honeypot or any other
    automation that is going to provide resources to VirusTotal and not only retrieve reports you are entitled to
    a higher request rate quota, ask for it at contact@virustotal.com and you will receive special privileges when
    performing the calls to the API. Note that you will only have a higher request rate quota when asking for files
    or URLs that you previously sent to VirusTotal.
    In this second version we have improved the response format so as to ease the task of retrieving results, we
    have also introduced batch requests, you may now ask for several items with a sole API call (as long as you
    cohere with the request rate limit).
    The public API is a free service, available for any website or application that is free to consumers. The API
    must not be used in commercial products or services, it can not be used as a substitute for antivirus products
    and it can not be integrated in any project that may harm the antivirus industry directly or indirectly.
    Noncompliance of these terms will result in inmediate permanent ban of the infractor individual or organization.
    """

    def __init__(self,type,name,by, proxies=None):

        Feeder.__init__(self, type, name, by)
        self.description = description
        self.log = C.getlog()
        self.api_key = C.Const.virustotal.api_key
        self.proxies = proxies
        self.sourcelink = C.Const.virustotal.s_link
        self.version = 2
        if self.api_key is None:
            raise ApiError("You must supply a valid VirusTotal API key.")

    def checkstatus(self):
        try:
            return self.url_ok(self.sourcelink)  # link is available
        except Exception as e:
            self.log.error(repr(e))
            return False

    def scan_file(self, this_file, from_disk=True, filename=None, timeout=None):
        """ Submit a file to be scanned by VirusTotal.
        The VirusTotal API allows you to send files. Before performing your submissions we encourage you to retrieve
        the latest report on the files, if it is recent enough you might want to save time and bandwidth by making use
        of it. File size limit is 32MB. If you have a need to scan larger files, please contact us, and tell us your
        use case.
        :param this_file: The file to be uploaded. (32MB file size limit)
        :param from_disk: If True we read the file contents from disk using this_file as filepath. If False this_file
                          is the actual file object.
        :param filename: Specify the filename, this overwrites the filename if we read a file from disk.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response that contains scan_id and permalink.
        """
        params = {'apikey': self.api_key}
        if from_disk:
            if not filename:
                filename = os.path.basename(this_file)
            files = {'file': (filename, open(this_file, 'rb').read())}
        else:
            if filename:
                files = {'file': (filename, this_file)}
            else:
                files = {'file': this_file}

        try:
            response = requests.post(
                self.sourcelink + 'file/scan', files=files, params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def rescan_file(self, this_hash, timeout=None):
        """ Rescan a previously submitted filed or schedule an scan to be performed in the future.
        :param this_hash: a md5/sha1/sha256 hash. You can also specify a CSV list made up of a combination of any of
                          the three allowed hashes (up to 25 items), this allows you to perform a batch request with
                          one single call. Note that the file must already be present in our file store.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response that contains scan_id and permalink.
        """
        params = {'apikey': self.api_key, 'resource': this_hash}

        try:
            response = requests.post(self.sourcelink + 'file/rescan', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def get_file_report(self, this_hash, timeout=None):
        """ Get the scan results for a file.
        You can also specify a CSV list made up of a combination of hashes and scan_ids
        (up to 4 items with the standard request rate), this allows you to perform a batch
        request with one single call.
        i.e. {'resource': '99017f6eebbac24f351415dd410d522d, 88817f6eebbac24f351415dd410d522d'}.
        :param this_hash: The md5/sha1/sha256/scan_ids hash of the file whose dynamic behavioural report you want to
                            retrieve or scan_ids from a previous call to scan_file.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return:
        """
        params = {'apikey': self.api_key, 'resource': this_hash}

        try:
            response = requests.get(self.sourcelink + 'file/report', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def scan_url(self, this_url, timeout=None):
        """ Submit a URL to be scanned by VirusTotal.
        Allows you to submit URLs to be scanned by VirusTotal. Before performing your submission we encourage you to
        retrieve the latest report on the URL, if it is recent enough you might want to save time and bandwidth by
        making use of it.
        :param this_url: The URL that should be scanned. This parameter accepts a list of URLs (up to 4 with the
                         standard request rate) so as to perform a batch scanning request with one single call. The
                         URLs must be separated by a new line character.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response that contains scan_id and permalink.
        """
        params = {'apikey': self.api_key, 'url': this_url}

        try:
            response = requests.post(self.sourcelink + 'url/scan', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def get_url_report(self, this_url, scan='0', timeout=None):
        """ Get the scan results for a URL. (can do batch searches like get_file_report)
        :param this_url: a URL will retrieve the most recent report on the given URL. You may also specify a scan_id
                         (sha256-timestamp as returned by the URL submission API) to access a specific report. At the
                         same time, you can specify a CSV list made up of a combination of hashes and scan_ids so as
                         to perform a batch request with one single call (up to 4 resources per call with the standard
                         request rate). When sending multiples, the scan_ids or URLs must be separated by a new line
                         character.
        :param scan: (optional): this is an optional parameter that when set to "1" will automatically submit the URL
                      for analysis if no report is found for it in VirusTotal's database. In this case the result will
                      contain a scan_id field that can be used to query the analysis report later on.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response
        """
        params = {'apikey': self.api_key, 'resource': this_url, 'scan': scan}

        try:
            response = requests.get(self.sourcelink + 'url/report', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def put_comments(self, resource, comment, timeout=None):
        """ Post a comment on a file or URL.
        The initial idea of VirusTotal Community was that users should be able to make comments on files and URLs,
        the comments may be malware analyses, false positive flags, disinfection instructions, etc.
        Imagine you have some automatic setup that can produce interesting results related to a given sample or URL
        that you submit to VirusTotal for antivirus characterization, you might want to give visibility to your setup
        by automatically reviewing samples and URLs with the output of your automation.
        :param resource: either a md5/sha1/sha256 hash of the file you want to review or the URL itself that you want
                         to comment on.
        :param comment: the actual review, you can tag it using the "#" twitter-like syntax (e.g. #disinfection #zbot)
                        and reference users using the "@" syntax (e.g. @VirusTotalTeam).
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: If the comment was successfully posted the response code will be 1, 0 otherwise.
        """
        params = {'apikey': self.api_key, 'resource': resource, 'comment': comment}

        try:
            response = requests.post(self.sourcelink + 'comments/put', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def get_ip_report(self, this_ip, timeout=None):
        """ Get IP address reports.
        :param this_ip: a valid IPv4 address in dotted quad notation, for the time being only IPv4 addresses are
                        supported.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response
        """
        params = {'apikey': self.api_key, 'ip': this_ip}

        try:
            response = requests.get(self.sourcelink + 'ip-address/report',
                                    params=params,
                                    proxies=self.proxies,
                                    timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

    def get_domain_report(self, this_domain, timeout=None):
        """ Get information about a given domain.
        :param this_domain: a domain name.
        :param timeout: The amount of time in seconds the request should wait before timing out.
        :return: JSON response
        """
        params = {'apikey': self.api_key, 'domain': this_domain}

        try:
            response = requests.get(self.sourcelink + 'domain/report', params=params, proxies=self.proxies, timeout=timeout)
        except requests.RequestException as e:
            return dict(error=str(e))

        return _return_response_and_status_code(response)

class ApiError(Exception):
    pass

def _return_response_and_status_code(response):
    """ Output the requests response JSON and status code
    :rtype : dict
    :param response: requests response object
    :return: dict containing the JSON response and/or the status code with error string.
    """
    if response.status_code == requests.codes.ok:
        return dict(results=response.json(), response_code=response.status_code)
    elif response.status_code == 204:
        return dict(
            error='You exceeded the public API request rate limit (4 requests of any nature per minute)',
            response_code=response.status_code)
    elif response.status_code == 403:
        return dict(
            error='You tried to perform calls to functions for which you require a Private API key.',
            response_code=response.status_code)
    else:
        return dict(response_code=response.status_code)



import json
import hashlib

#EICAR = "X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
#EICAR_MD5 = hashlib.md5(EICAR).hexdigest()

vt = PublicApi("Ben",'Ben',"Ben")

response = vt.get_file_report('44D88612FEA8A8F36DE82E1278ABB02F')
print(json.dumps(response, sort_keys=False, indent=4))